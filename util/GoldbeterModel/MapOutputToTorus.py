'''
Map the solution of the Goldbeter model found from the C script onto the torus generated by GenTorus
'''

# imports
import vtk
import os
import sys
import lxml
import lxml.etree
import numpy as np
import argparse
import math
from configobj import ConfigObj

def XYZtoRC(xyz,ny,nx,r,R):
    '''Convert (x,y,z) to (phi,theta) to (row,column) of results array'''
    
    x = xyz[0]
    y = xyz[1]
    z = xyz[2]

    # Convert (x,y,z) coordinates to (phi, theta).
    phi = math.atan2(z,x) % (2*np.pi)
    
    if (np.sqrt(x*x + z*z) > R):    # i.e. if the point lies on the outer half of the torus
        theta = (np.arcsin(y/r)) % (2*np.pi)   
    else:
        theta = (np.pi - np.arcsin(y/r)) % (2*np.pi)

    # Finds the row and column of the results array that match the given coords
    # using the number of rows (ny) and number of columns (nx)
    rc = (int(phi/(2*np.pi) * (ny-1)), int(theta/(2*np.pi) * (nx-1)) )

    return phi, theta, rc
    

if __name__ == '__main__':

    # Obtain ini file
    parser = argparse.ArgumentParser()
    parser.add_argument("configFile", help="config file path")
    args = parser.parse_args()

    # Load relevant parameters from ini file
    conf = ConfigObj(args.configFile)
    parameters = conf['Parameters']
    systemParameters = conf['System']
    majorCirc = parameters['surfaceLength']
    minorCirc = parameters['surfaceWidth']
    thetaMesh = parameters['xMesh']
    tFinal = parameters['tFinal']
    includeAllVars = int(systemParameters['includeAllVars'])
    varyBeta = int(systemParameters['varyBeta'])

    # Minor and major radii
    r = float(minorCirc)/(2*np.pi)
    R = float(majorCirc)/(2*np.pi)

    # Hopf bifurcation positions (only for Goldbeter model!)
    if (varyBeta == 1):
        lHopf = 0.289*2*np.pi
        rHopf = 0.774*2*np.pi
    
    # determine the number of MPI processes used
    nprocs=1
    for i in range(1000):
        sname = 'GoldbeterModel_torus_subdomain.' + repr(i).zfill(3) + '.txt'
        try:
            f = open(sname,'r')
            f.close()
        except IOError:
            nprocs = i
            break
    
    # load subdomain information, store in table
    subdomains = np.zeros((nprocs,4), dtype=np.int)
    for i in range(nprocs):
        sname = 'GoldbeterModel_torus_subdomain.' + repr(i).zfill(3) + '.txt'
        subd = np.loadtxt(sname, dtype=np.float)
        if (i == 0):
            nx = int(subd[0])
            ny = int(subd[1])
        else:
            if ((subd[0] != nx) or (subd[1] != ny)):
                sys.exit("error: subdomain files incompatible (clean up and re-run test)")
        subdomains[i,:] = subd[2:6]
       
    # load first processor's data for variables Z and Y   
    dataZ = np.loadtxt('GoldbeterModel_torus_Z.000.txt', dtype=np.double)
    if (includeAllVars == 1): dataY = np.loadtxt('GoldbeterModel_torus_Y.000.txt', dtype=np.double)

    # determine total number of time steps
    nt = np.shape(dataZ)[0]
    
    # create empty array for all solution data of the variable(s)
    resultsZ = np.zeros((nt,ny,nx))
    if (includeAllVars == 1): resultsY = np.zeros((nt,ny,nx))
    
    # insert first processor's data into results array
    istart = subdomains[0,0]
    iend = subdomains[0,1]
    jstart = subdomains[0,2]
    jend = subdomains[0,3]
    nxl = iend - istart + 1
    nyl = jend - jstart + 1
    
    for i in range(nt):
        resultsZ[i, jstart:jend+1, istart:iend+1] = np.reshape(dataZ[i,:], (nyl,nxl))
        if (includeAllVars == 1): resultsY[i, jstart:jend+1, istart:iend+1] = np.reshape(dataY[i,:], (nyl,nxl))
        
    # iterate over remaining data files, inserting into output
    if (nprocs > 1):
        
        for isub in range(1,nprocs):
            dataZ = np.loadtxt('GoldbeterModel_torus_Z.' + repr(isub).zfill(3) + '.txt', dtype=np.double)
            if (includeAllVars == 1): dataY = np.loadtxt('GoldbeterModel_torus_Y.' + repr(isub).zfill(3) + '.txt', dtype=np.double)
            
            # check that subdomain has correct number of time steps
            if (np.shape(dataZ)[0] != nt):
                sys.exit('error: subdomain ' + isub + ' has an incorrect number of time steps')
                
            istart = subdomains[isub,0]
            iend = subdomains[isub,1]
            jstart = subdomains[isub,2]
            jend = subdomains[isub,3]
            nxl = iend-istart+1
            nyl = jend-jstart+1
            
            for i in range(nt):
                resultsZ[i,jstart:jend+1,istart:iend+1] = np.reshape(dataZ[i,:], (nyl,nxl))
                if (includeAllVars == 1): resultsY[i,jstart:jend+1,istart:iend+1] = np.reshape(dataY[i,:], (nyl,nxl))

    tStepDict = dict()

    # Create directory for each time step output vtp file
    os.system("mkdir -p GBstep")

    for tstep in range(nt):
        
        # Get the time at tstep
        time = ((float(tstep) / float(nt))) * float(tFinal) # get time of output
        
        # Read geometry from disk
        torusReader = vtk.vtkXMLPolyDataReader()
        torusReader.SetFileName("torus_R" + majorCirc + "_r" + minorCirc + "_mesh" + thetaMesh + ".vtp")
        torusReader.Update()
        torus = torusReader.GetOutput()
        
        # Obtain cell centres
        cellCentresFilter = vtk.vtkCellCenters()
        cellCentresFilter.SetInputData(torus)
        cellCentresFilter.Update()
        cellCentres = cellCentresFilter.GetOutput()
        
        ZArray = vtk.vtkDoubleArray()
        ZArray.SetName("Cytosolic Calcium")

        if (varyBeta == 1):
            HopfArray = vtk.vtkDoubleArray()
            HopfArray.SetName("Hopf Bifurcations")
        
        if (includeAllVars == 1):
            YArray = vtk.vtkDoubleArray()
            YArray.SetName("Calcium in Stores")
        
        # Iterate over all centres
        for cId in range(cellCentres.GetNumberOfPoints()):
            point = cellCentres.GetPoint(cId)
            
            phi, theta, rc = XYZtoRC(point,ny,nx,r,R)
            
            resultZ = resultsZ[tstep,rc[0],rc[1]]
            if (includeAllVars == 1): resultY = resultsY[tstep,rc[0],rc[1]]

            # Set to 1 if it's at one of the Hopf bifurcation, otherwise 0
            if (varyBeta == 1):
                if (abs(phi - lHopf) < 0.01) or (abs(phi - rHopf) < 0.01):
                    resultHopf = 1
                else:
                    resultHopf = 0

            ZArray.InsertNextValue(resultZ)
            if (varyBeta == 1): HopfArray.InsertNextValue(resultHopf)
            if (includeAllVars == 1): YArray.InsertNextValue(resultY)
        
        torus.GetCellData().AddArray(ZArray)  # main variable
        if (varyBeta == 1): torus.GetCellData().AddArray(HopfArray) # Hopf bifurcations
        if (includeAllVars == 1): torus.GetCellData().AddArray(YArray)    # other variable(s)

        outputFileName = "GBstep/GBstep_" + repr(tstep).zfill(3) + ".vtp"

        tStepDict[time] = outputFileName
        
        writer = vtk.vtkXMLPolyDataWriter()
        writer.SetInputData(torus)
        writer.SetFileName(outputFileName)
        writer.Update()

    # Create new root of the XML tree.
    vtkFileElem = lxml.etree.Element('VTKFile', type="Collection", version='0.1', byte_order='LittleEndian', compressor='vtkZLibDataCompressor')

    # Create new XML document.
    pvdDoc = lxml.etree.ElementTree(vtkFileElem)

    # Add 'Collections' element, as a subelement of the 'VTKFile'.
    collectionElem = lxml.etree.SubElement(vtkFileElem, 'Collection')

    for time in tStepDict:
        tstr = repr(float("{0:.1f}".format(time)))  # convert to string with 1 decimal place
        # Add 'DataSet' element as a subelement of ... whatever.
        dataElem = lxml.etree.SubElement(collectionElem, 'DataSet', timestep=tstr, group='', part='0', file=tStepDict[time])

    # Print the tree to the console.
    outXMLFile = open('GBtimeSteps.pvd', 'w')
    pvdDoc.write(outXMLFile, encoding='iso-8859-1', xml_declaration=True, pretty_print=True, method = 'xml')

    print "\nMapping to torus complete!"
